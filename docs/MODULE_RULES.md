# Module Organization Rules

This document defines the structural and organizational rules for all modules in the EduTech Backend API (MongoDB + Mongoose).

## 1. Module Folder Structure

Every module must follow this exact directory structure:

```
src/
├── enums/                                     # Shared enums (if applicable)
│   ├── {entity}-status.enum.ts               # Status enums
│   └── index.ts                              # Barrel export
└── {module-name}/
    ├── domain/
    │   └── {entity}.ts                       # Domain interface (imports enums if needed)
    ├── dto/
    │   ├── create-{entity}.dto.ts
    │   ├── update-{entity}.dto.ts
    │   ├── {entity}.dto.ts
    │   ├── paginated-{entity}.dto.ts
    │   └── index.ts
    ├── infrastructure/
    │   └── persistence/
    │       └── document/
    │           ├── schemas/
    │           │   ├── {entity}.schema.ts
    │           │   └── index.ts
    │           ├── mappers/
    │           │   ├── {entity}.mapper.ts
    │           │   └── index.ts
    │           ├── repositories/
    │           │   ├── {entity}.repository.abstract.ts  # Abstract base class
    │           │   └── index.ts
    │           ├── {entity}.repository.ts               # Implementation
    │           ├── document-persistence.module.ts
    │           └── index.ts
    ├── {module-name}.controller.ts
    ├── {module-name}.service.ts
    ├── {module-name}.module.ts
    └── index.ts
```

## 2. Domain Layer Rules

### 2.1 File Naming

- File: `{entity}.ts` (singular, camelCase)
- Example: `track.ts`, `user.ts`

### 2.2 Enum Extraction Rule (IMPORTANT)

- **ALL enums MUST be extracted to `src/enums/` directory**
- Naming: `{entity}-status.enum.ts` (or other descriptive enum name)
- MUST NOT be defined in domain file
- Barrel export from `src/enums/index.ts`
- Domain imports from enums: `import { TrackStatus } from '../../enums'`

**Rationale**: Enums are shared concerns that may be used across multiple modules (domain, DTO, entity, API responses). Extracting them to a central location prevents circular dependencies and improves reusability.

### 2.3 Content Requirements

- Must export an `interface {Entity}` representing the data contract
- Must import enums from `src/enums/` if applicable
- Must export a class `{Entity}Domain` implementing the interface (optional, for complex logic)
- MUST NOT contain any ORM decorators (@Schema, @Prop, @Entity, @Column, etc.)
- MUST NOT contain any NestJS decorators (@Injectable, @Controller, etc.)
- MUST NOT import from infrastructure layer

### 2.4 Example

```typescript
// src/enums/track-status.enum.ts
export enum TrackStatus {
  Uploaded = 'uploaded',
  Processing = 'processing',
  Ready = 'ready',
  Failed = 'failed',
}

// src/tracks/domain/track.ts
import { TrackStatus } from '../../enums'; // Import from enums

export interface Track {
  id: string;
  title: string;
  status: TrackStatus;
  createdAt: Date;
  updatedAt: Date;
}

export class TrackDomain implements Track {
  // Optional: Add business logic methods
}
```

## 3. DTO Layer Rules

### 3.1 File Naming

- Create: `create-{entity}.dto.ts`
- Update: `update-{entity}.dto.ts`
- Response: `{entity}.dto.ts`
- Paginated: `paginated-{entity}.dto.ts`
- Example: `create-track.dto.ts`, `update-track.dto.ts`

### 3.2 Content Requirements

- Use `@nestjs/class-validator` decorators for validation
- Response DTOs must extend/mirror domain interface
- Paginated DTOs must follow PaginatedResponse pattern:

```typescript
export class PaginatedTracksDto {
  @ApiProperty({ type: [TrackDto] })
  @Type(() => TrackDto)
  data: TrackDto[];

  @ApiProperty()
  total: number;

  @ApiProperty()
  limit: number;

  @ApiProperty()
  offset: number;
}
```

### 3.3 Barrel Export

All DTOs must be exported from `dto/index.ts`:

```typescript
export * from './create-track.dto';
export * from './update-track.dto';
export * from './track.dto';
export * from './paginated-tracks.dto';
```

## 4. Schema Layer Rules (Mongoose)

### 4.1 File Location & Naming

- Location: `infrastructure/persistence/document/schemas/`
- File: `{entity}.schema.ts`
- Example: `user.schema.ts`

### 4.2 Content Requirements

- MUST have `@Schema({ timestamps: true, collection: '{collection-name}' })` decorator
- MongoDB `_id` field is automatically created (mapped to `id` by mapper)
- MUST use Mongoose `@Prop()` decorators for all properties
- MUST use snake_case for collection names (e.g., `collection: 'student_profiles'`)
- Timestamps (`createdAt`, `updatedAt`) are auto-generated by `{ timestamps: true }`
- **CRITICAL**: For union types (e.g., `string | null`, `Date | null`), MUST use explicit `type` parameter: `@Prop({ type: String, default: null })` to avoid Mongoose `CannotDetermineTypeError`
- Use `HydratedDocument<T>` type for typed documents

### 4.3 Naming Convention

- Class name: `{Entity}Document` (PascalCase + Document suffix)
- Collection name: lowercase with underscores (`@Schema({ collection: 'collection_name' })`)
- Example: `UserDocument`, collection `users`
- Export schema: `{Entity}Schema` (e.g., `UserSchema = SchemaFactory.createForClass(UserDocument)`)

### 4.4 Example

```typescript
// src/users/infrastructure/persistence/document/schemas/user.schema.ts
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { HydratedDocument } from 'mongoose';
import { UserRole } from '../../../../../enums';

@Schema({ timestamps: true, collection: 'users' })
export class UserDocument {
  @Prop({ required: true, unique: true, lowercase: true, trim: true })
  email!: string;

  // ✅ CRITICAL: Union types require explicit type parameter
  @Prop({ type: String, default: null })
  passwordHash?: string | null;

  @Prop({ enum: UserRole, default: UserRole.Student })
  role!: UserRole;

  @Prop({ type: String, default: null })
  avatarUrl?: string | null;

  @Prop({ default: true })
  isActive!: boolean;
}

export type UserDocumentType = HydratedDocument<UserDocument> & {
  createdAt: Date;
  updatedAt: Date;
};

export const UserSchema = SchemaFactory.createForClass(UserDocument);
```

### 4.5 Barrel Export

Schemas must be exported from `schemas/index.ts`:

```typescript
export * from './user.schema';
export * from './student-profile.schema';
// ... other schemas
```

## 5. Mapper Layer Rules

### 5.1 File Location & Naming

- Location: `infrastructure/persistence/document/mappers/`
- File: `{entity}.mapper.ts`
- Example: `user.mapper.ts`

### 5.2 Content Requirements

- MUST be `@Injectable()` provider
- MUST have three methods:
  - `toDomain(document: {Entity}DocumentType): {Entity}`
  - `toDocument(domain: {Entity} | Partial<{Entity}>): Partial<{Entity}Document>`
  - `toDomainArray(documents: {Entity}DocumentType[]): {Entity}[]`

### 5.3 Responsibility

- Transforms Mongoose documents → domain models
- Transforms domain models → Mongoose documents (for creation/update)
- Handles all type conversions and property mappings (e.g., `_id` → `id`)
- NO business logic, only data transformation

### 5.4 Example

```typescript
// src/users/infrastructure/persistence/document/mappers/user.mapper.ts
import { Injectable } from '@nestjs/common';
import { User } from '../../../../domain/user';
import { UserDocument, UserDocumentType } from '../schemas/user.schema';

@Injectable()
export class UserMapper {
  toDomain(document: UserDocumentType): User {
    return {
      id: document._id.toString(), // ✅ Map MongoDB _id to domain id
      email: document.email,
      passwordHash: document.passwordHash ?? undefined,
      role: document.role,
      avatarUrl: document.avatarUrl ?? undefined,
      isActive: document.isActive,
      createdAt: document.createdAt,
      updatedAt: document.updatedAt,
    };
  }

  toDocument(domain: User | Partial<User>): Partial<UserDocument> {
    const { id, createdAt, updatedAt, ...rest } = domain as any;
    return rest; // Exclude id and timestamps (managed by Mongoose)
  }

  toDomainArray(documents: UserDocumentType[]): User[] {
    return documents.map((doc) => this.toDomain(doc));
  }
}
```

### 5.5 Barrel Export

Mappers must be exported from `mappers/index.ts`:

```typescript
export * from './track.mapper';
export * from './user.mapper';
// ... other mappers
```

## 6. Repository Abstract Class Rules

### 6.1 File Location & Naming

- Location: `infrastructure/persistence/document/repositories/`
- File: `{entity}.repository.abstract.ts`
- Example: `user.repository.abstract.ts`

### 6.2 Content Requirements

- MUST be a **standalone** `abstract class {Entity}RepositoryAbstract`
- **MUST NOT** extend BaseRepository (composition over inheritance)
- MUST define all public repository methods as abstract
- MUST include standard CRUD methods: `findById()`, `findAll()`, `create()`, `update()` (if applicable), `delete()`
- MUST use domain types in signatures (not entities)
- Return types MUST be Promises
- NO implementation, only method signatures
- NO constructor needed (standalone abstract class)

### 6.3 Required Methods

All abstract repositories must declare these standard CRUD methods:

- **Read Operations**:
  - `abstract findById(id: string): Promise<{Entity} | null>`
  - `abstract findAll(limit: number, offset: number): Promise<[{Entity}[], number]>`
- **Write Operations**:
  - `abstract create({entity}: Partial<{Entity}>): Promise<{Entity}>`
  - `abstract update(id: string, {entity}: Partial<{Entity}>): Promise<{Entity}>` (if updates supported)
  - `abstract delete(id: string): Promise<void>`
- **Custom Methods**: Domain-specific queries

### 6.4 Example

```typescript
// src/users/infrastructure/persistence/document/repositories/user.repository.abstract.ts
import { User } from '../../../../domain/user';

export abstract class UserRepositoryAbstract {
  // CRUD methods
  abstract findById(id: string): Promise<User | null>;
  abstract findAll(limit: number, offset: number): Promise<[User[], number]>;
  abstract create(user: Partial<User>): Promise<User>;
  abstract update(id: string, user: Partial<User>): Promise<User>;
  abstract delete(id: string): Promise<void>;

  // Custom methods specific to User domain
  abstract findByEmail(email: string): Promise<User | null>;
}
```

### 6.5 Barrel Export

Abstract classes must be exported from `repositories/index.ts`:

```typescript
export * from './track.repository.abstract';
export * from './user.repository.abstract';
// ... other abstracts
```

## 7. Repository Implementation Rules

### 7.1 File Location & Naming

- Location: `infrastructure/persistence/document/`
- File: `{entity}.repository.ts`
- Example: `user.repository.ts`

### 7.2 Content Requirements

- MUST be `@Injectable()` provider
- MUST extend `{Entity}RepositoryAbstract` abstract class
- MUST inject Mongoose `Model<{Entity}Document>` using `@InjectModel()`
- MUST inject `{Entity}Mapper` for transformations
- MUST use `this.mapper` for all transformations (Document ↔ Domain)
- MUST return domain types (not Mongoose documents)

### 7.3 Architecture Pattern

**Direct Mongoose Model Usage**: Concrete repositories:

1. Extend their domain-specific abstract class
2. Inject Mongoose Model via `@InjectModel({Entity}Document.name)`
3. Use Model methods directly (`.find()`, `.findById()`, `.create()`, etc.)
4. Apply mapper transformations to convert between Mongoose documents and domain objects

**Benefits**:

- Abstract repositories remain pure interfaces (no implementation coupling)
- Direct access to Mongoose's powerful query API
- Concrete repositories focus on domain-specific logic and mapping

### 7.4 Constructor Pattern

```typescript
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserDocument, UserDocumentType } from './schemas/user.schema';
import { UserMapper } from './mappers/user.mapper';
import { UserRepositoryAbstract } from './repositories/user.repository.abstract';

@Injectable()
export class UserRepository extends UserRepositoryAbstract {
  constructor(
    @InjectModel(UserDocument.name) private userModel: Model<UserDocument>,
    private readonly mapper: UserMapper,
  ) {
    super();
  }
}
```

### 7.5 Method Implementation Pattern

**Using Mongoose Model for CRUD**:

```typescript
// Generic findById using Mongoose
async findById(id: string): Promise<User | null> {
  const document = await this.userModel.findById(id).exec();
  return document ? this.mapper.toDomain(document) : null;
}

// Generic findAll using Mongoose
async findAll(limit = 10, offset = 0): Promise<[User[], number]> {
  const [documents, total] = await Promise.all([
    this.userModel.find().skip(offset).limit(limit).exec(),
    this.userModel.countDocuments().exec(),
  ]);
  return [this.mapper.toDomainArray(documents), total];
}

// Generic create using Mongoose
async create(user: Partial<User>): Promise<User> {
  const documentData = this.mapper.toDocument(user);
  const created = await this.userModel.create(documentData);
  return this.mapper.toDomain(created);
}

// Generic update using Mongoose
async update(id: string, user: Partial<User>): Promise<User> {
  const documentData = this.mapper.toDocument(user);
  const updated = await this.userModel
    .findByIdAndUpdate(id, documentData, { new: true })
    .exec();
  if (!updated) throw new Error('User not found');
  return this.mapper.toDomain(updated);
}

// Generic delete using Mongoose
async delete(id: string): Promise<void> {
  await this.userModel.findByIdAndDelete(id).exec();
}

// Custom domain-specific method
async findByEmail(email: string): Promise<User | null> {
  const document = await this.userModel.findOne({ email }).exec();
  return document ? this.mapper.toDomain(document) : null;
}
```

### 7.6 Mongoose Model Injection

**Model Injection Pattern**:

- Use `@InjectModel({Entity}Document.name)` to inject Mongoose model
- Model provides type-safe access to collection operations
- All queries return `HydratedDocument<T>` for full TypeScript support

```typescript
// Injecting Mongoose Model
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { UserDocument } from './schemas/user.schema';

@Injectable()
export class UserRepository extends UserRepositoryAbstract {
  constructor(
    @InjectModel(UserDocument.name) private userModel: Model<UserDocument>,
    private readonly mapper: UserMapper,
  ) {
    super();
  }
}
```

## 8. Service Layer Rules

### 8.1 File Naming

- File: `{module-name}.service.ts`
- Example: `tracks.service.ts`

### 8.2 Content Requirements

- MUST be `@Injectable()` provider
- Orchestrates repository and other services
- Implements business logic
- Returns domain types (from repositories)
- Accepts DTOs from controllers
- Transforms DTOs → domain models (internally, optional)

### 8.3 Constructor Pattern

```typescript
@Injectable()
export class TracksService {
  constructor(private readonly trackRepository: TrackRepository) {}
}
```

### 8.4 Method Naming

- `async create(dto: CreateTrackDto): Promise<Track>`
- `async findOne(id: string): Promise<Track>`
- `async findAll(): Promise<[Track[], number]>`
- `async update(id: string, dto: UpdateTrackDto): Promise<Track>`
- `async delete(id: string): Promise<void>`

## 9. Controller Layer Rules

### 9.1 File Naming

- File: `{module-name}.controller.ts`
- Example: `tracks.controller.ts`

### 9.2 Content Requirements

- MUST be `@Controller('{route}')` decorated
- Dependency inject service layer only
- Accept DTOs with `@Body()` validation
- Call service methods (not repository)
- Transform responses using DTOs

### 9.3 Example Pattern

```typescript
@Controller('tracks')
@ApiTags('Tracks')
export class TracksController {
  constructor(private readonly tracksService: TracksService) {}

  @Post()
  @UseInterceptors(FileInterceptor('file'))
  async create(
    @UploadedFile() file: Express.Multer.File,
    @Body() dto: CreateTrackDto,
  ): Promise<TrackDto> {
    const track = await this.tracksService.createFromUpload(file, dto);
    return this.toTrackDto(track);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<TrackDto> {
    const track = await this.tracksService.findOne(id);
    return this.toTrackDto(track);
  }
}
```

## 10. Module Wiring Rules

### 10.1 Document Persistence Module

File: `infrastructure/persistence/document/document-persistence.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UserDocument, UserSchema } from './schemas/user.schema';
import { UserMapper } from './mappers/user.mapper';
import { UserRepository } from './user.repository';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: UserDocument.name, schema: UserSchema },
    ]),
  ],
  providers: [UserMapper, UserRepository],
  exports: [UserRepository], // Export repository only
})
export class DocumentUserPersistenceModule {}
```

### 10.2 Main Module

File: `{module-name}.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { DocumentUserPersistenceModule } from './infrastructure/persistence/document/document-persistence.module';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [DocumentUserPersistenceModule],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService], // Export service for other modules
})
export class UsersModule {}
```

### 10.3 Barrel Exports

Each module must export public API from `index.ts`:

```typescript
// src/tracks/index.ts
export * from './dto';
export * from './domain/track';
export * from './tracks.service';
export * from './tracks.module';
```

## 11. Dependency Injection Rules

### 11.1 Injection Hierarchy

```
Controller
    ↓ (injects)
Service
    ↓ (injects)
Repository
    ↓ (uses)
Entity + Mapper
```

### 11.2 No Circular Dependencies

- Controllers MUST NOT inject repositories directly
- Services MUST NOT inject controllers
- Domain layer MUST NOT depend on infrastructure

### 11.3 Provider Registration

- Register in module `providers` array
- Export from module if used by other modules
- Use `@Injectable()` decorator

## 12. Naming Conventions Summary

| Layer                       | Pattern                                       | Example                  |
| --------------------------- | --------------------------------------------- | ------------------------ |
| Enum                        | `{Entity}Status`                              | `UserRole`               |
| Domain                      | `{Entity}` interface + `{Entity}Domain` class | `User`, `UserDomain`     |
| Schema (Mongoose)           | `{Entity}Document` class                      | `UserDocument`           |
| Schema Factory              | `{Entity}Schema` constant                     | `UserSchema`             |
| Mapper                      | `{Entity}Mapper` service                      | `UserMapper`             |
| Repository (Abstract)       | `{Entity}RepositoryAbstract`                  | `UserRepositoryAbstract` |
| Repository (Implementation) | `{Entity}Repository`                          | `UserRepository`         |
| Service                     | `{Entity}Service`                             | `UsersService`           |
| Controller                  | `{Entity}Controller`                          | `UsersController`        |
| DTO (Create)                | `Create{Entity}Dto`                           | `CreateUserDto`          |
| DTO (Update)                | `Update{Entity}Dto`                           | `UpdateUserDto`          |
| DTO (Response)              | `{Entity}Dto`                                 | `UserDto`                |
| Module                      | `{Entity}Module`                              | `UsersModule`            |

## 13. Import Rules

### 13.1 Allowed Imports

```typescript
// ✅ Service importing from domain
import { Track } from './domain/track';

// ✅ Service/Domain importing from enums
import { TrackStatus } from '../../enums';

// ✅ Entity importing from enums
import { TrackStatus } from '../../../../../enums';

// ✅ DTO importing from enums and domain
import { TrackStatus } from '../../enums';
import { Track } from '../../domain/track';

// ✅ Repository importing from domain
import { Track } from '../domain/track';

// ✅ Controller importing from dto
import { TrackDto, CreateTrackDto } from './dto';

// ✅ Service importing repository
import { UserRepository } from './infrastructure/persistence/document/user.repository';
```

### 13.2 Forbidden Imports

```typescript
// ❌ Domain/DTO importing from infrastructure
import { UserDocument } from './infrastructure/persistence/document/schemas/user.schema';

// ❌ Importing abstract class as interface (use extends instead)
import { ITrackRepository } from './repositories/track.repository.interface';

// ❌ Controller importing repository directly
import { UserRepository } from './infrastructure/persistence/document/user.repository';

// ❌ Infrastructure importing from HTTP layer
import { TrackController } from './tracks.controller';

// ❌ Importing enum from domain (should import from enums)
import { TrackStatus } from './domain/track'; // WRONG
// Instead:
import { TrackStatus } from '../../enums'; // CORRECT
```

### 13.3 Interface Extraction Rules

- **One interface per file** inside `<module>/interfaces/` (or `/config/interfaces` for config-only types).
- **Barrel export** all interfaces from `interfaces/index.ts`; consumers import from the barrel, never deep paths.
- **No inline interface declarations** inside services, strategies, processors, or config files—move them to `interfaces/`.
- **Naming**: `{descriptive-name}.interface.ts` (e.g., `oauth-profile.interface.ts`, `stream-payload.interface.ts`, `transcode-job.interface.ts`).
- **Example structure**:

```
src/auth/interfaces/oauth-profile.interface.ts
src/auth/interfaces/jwt-payload.interface.ts
src/auth/interfaces/index.ts
```

- **Usage**:

```typescript
// ✅ Service/strategy importing shared interface
import { OAuthProfile } from './interfaces';
```

## 14. File Size Guidelines

| File Type                 | Max Lines | Purpose                  |
| ------------------------- | --------- | ------------------------ |
| Enum                      | 10-30     | Status/state definitions |
| Domain                    | 50-100    | Pure data structures     |
| DTO                       | 30-60     | Validation rules         |
| Schema (Mongoose)         | 40-80     | ODM mapping              |
| Mapper                    | 40-80     | Data transformation      |
| Repository Abstract       | 20-40     | Contract definition      |
| Repository Implementation | 80-150    | Data access              |
| Service                   | 150-300   | Business logic           |
| Controller                | 100-200   | HTTP endpoints           |
| Module                    | 20-40     | Dependency wiring        |

_If files exceed these limits, consider splitting into sub-modules or extracting helper services._

## 15. Testing Strategy

### 15.1 What to Test

- **Enum**: N/A (no logic)
- **Domain**: Business logic methods (if any)
- **Mapper**: `toDomain()` and `toDocument()` transformations
- **Repository**: All data access methods (with mock Mongoose Model)
- **Service**: All business logic (with mocked repositories)
- **Controller**: HTTP contract (with mocked services)

### 15.2 Test File Naming

- Domain logic: `{entity}.spec.ts` in domain folder
- Service: `{module-name}.service.spec.ts`
- Controller: `{module-name}.controller.spec.ts`
- Repository: `{entity}.repository.spec.ts` in repository folder

## 16. Validation Rules

### 16.1 DTO Validation

All DTOs must use `class-validator` decorators:

```typescript
import { IsString, IsOptional, MaxLength, MinLength } from 'class-validator';

export class CreateTrackDto {
  @IsString()
  @MinLength(1)
  @MaxLength(255)
  title!: string;

  @IsOptional()
  @IsString()
  description?: string;
}
```

### 16.2 Custom Validators

Create custom decorators in `validators/` folder if needed:

```typescript
// src/validators/is-valid-uuid.validator.ts
export class IsValidUuid implements ValidatorConstraintInterface {
  validate(value: string) {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
      value,
    );
  }
}
```

## 17. Error Handling

### 17.1 Error Types by Layer

- **Controller**: HTTP exceptions (`BadRequestException`, `NotFoundException`, etc.)
- **Service**: Custom business exceptions or HTTP exceptions
- **Repository**: Catch Mongoose errors, throw application exceptions

### 17.2 Example

```typescript
// In Service
async findOneOrFail(id: string): Promise<Track> {
  const track = await this.trackRepository.findById(id);
  if (!track) {
    throw new NotFoundException(`Track with id ${id} not found`);
  }
  return track;
}
```

## 18. Documentation Rules

### 18.1 JSDoc Comments

- All public methods must have JSDoc comments
- All complex algorithms must be explained
- All parameters and return types documented

```typescript
/**
 * Creates a new track from uploaded file
 * @param file - Multer file object with audio content
 * @param dto - Track creation data
 * @returns Promise resolving to created Track domain object
 * @throws BadRequestException if file is missing
 */
async createFromUpload(file: Express.Multer.File, dto: CreateTrackDto): Promise<Track>
```

### 18.2 Module Documentation

Each module should include `README.md`:

```markdown
# Tracks Module

Handles track management, including:

- Track creation and metadata
- Audio file storage and streaming
- Asynchronous transcoding via BullMQ

## Public API

- `TracksService.findOne(id)`
- `TracksService.create(dto)`
- `TracksService.findAll()`

## Dependencies

- StorageService (S3 uploads)
- MediaQueue (Transcoding jobs)
```

## 19. Checklist for New Modules

- [ ] Domain layer created with interface
- [ ] Enums extracted to `src/enums/` module (if applicable)
- [ ] DTOs created for create/update/list/single response
- [ ] Schema created with Mongoose decorators (`@Schema`, `@Prop`)
- [ ] Union type fields have explicit `type` parameter (e.g., `@Prop({ type: String, default: null })`)
- [ ] Mapper created with toDomain/toDocument methods
- [ ] Repository abstract class defined
- [ ] Repository implementation created (extends abstract, injects Model)
- [ ] Persistence module configured with MongooseModule.forFeature()
- [ ] Service layer implementing business logic
- [ ] Controller with all CRUD endpoints
- [ ] Module wiring complete
- [ ] Barrel exports in place
- [ ] JSDoc comments added
- [ ] Unit tests written (optional but recommended)
- [ ] API documentation via Swagger decorators

## 20. Enum Organization Rules

### 20.1 Where to Place Enums

- Location: `src/enums/` directory (top-level, not inside modules)
- File naming: `{entity}-{type}.enum.ts`
- Examples: `track-status.enum.ts`, `user-role.enum.ts`

### 20.2 Enum Extraction Rule

**MANDATORY**: Any enum that represents a status, type, or role of an entity MUST be:

1. Defined in `src/enums/{entity}-{type}.enum.ts`
2. Exported from `src/enums/index.ts`
3. Imported by domain, entity, DTO, and service layers
4. NEVER defined inline in domain, dto, or entity files

### 20.3 Rationale

Enums are cross-cutting concerns used by:

- Domain layer (in type definitions)
- Entity layer (in ORM decorators)
- DTO layer (in response DTOs)
- Service layer (in business logic)
- Controller layer (in API responses)

Centralizing them prevents circular dependencies and ensures consistency.

### 20.4 Structure Example

```
src/
├── enums/
│   ├── track-status.enum.ts          # TrackStatus enum
│   ├── user-role.enum.ts             # UserRole enum (if needed)
│   └── index.ts                      # Barrel export
├── tracks/
│   ├── domain/track.ts               # imports TrackStatus from enums
│   ├── dto/track.dto.ts              # imports TrackStatus from enums
│   └── infrastructure/.../track.entity.ts  # imports TrackStatus from enums
└── users/
    └── ...
```

### 20.5 Barrel Export Pattern

```typescript
// src/enums/index.ts
export * from './track-status.enum';
export * from './user-role.enum';
// ... other enums
```

### 20.6 Usage in Different Layers

```typescript
// Domain layer
import { UserRole } from '../../enums';
export interface User {
  role: UserRole;
}

// DTO layer
import { UserRole } from '../../enums';
export class UserDto {
  @ApiProperty({ enum: UserRole })
  role: UserRole;
}

// Schema layer
import { UserRole } from '../../../../../enums';
@Schema()
export class UserDocument {
  @Prop({ enum: UserRole, default: UserRole.Student })
  role: UserRole;
}
```

## 21. Authentication & Authorization Rules

### 21.1 JWT Authentication Setup

**Location**: `src/auth/` module handles all authentication concerns.

**Components**:

- `JwtStrategy`: Passport strategy that validates JWT tokens and loads user
- `JwtAuthGuard`: Guard that protects endpoints requiring authentication
- `@CurrentUser` decorator: Extracts authenticated user from request

### 21.2 Protecting Endpoints

All endpoints requiring authentication MUST use `@UseGuards(JwtAuthGuard)`:

```typescript
import { Controller, Post, UseGuards } from '@nestjs/common';
import { JwtAuthGuard, CurrentUser } from '../auth';
import { User } from '../users/domain/user';
import { ApiBearerAuth } from '@nestjs/swagger';

@Controller('tracks')
@ApiTags('Tracks')
export class TracksController {
  @Post()
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth() // Adds "Authorize" button in Swagger UI
  async upload(
    @Body() dto: CreateTrackDto,
    @CurrentUser() user: User, // Automatically extracts user from JWT token
  ) {
    return this.tracksService.create(dto, user.id);
  }
}
```

### 21.3 User ID Extraction Rule (IMPORTANT)

**NEVER accept `userId` from request body or query parameters for actions on behalf of authenticated users.**

❌ **WRONG - Security Vulnerability**:

```typescript
export class CreateTrackDto {
  @ApiProperty()
  userId!: string; // ❌ User can fake this!
}

@Post()
async upload(@Body() dto: CreateTrackDto) {
  return this.service.create(dto.userId); // ❌ Insecure!
}
```

✅ **CORRECT - Extract from JWT Token**:

```typescript
export class CreateTrackDto {
  @ApiProperty()
  title!: string;
  // ✅ No userId field - extracted from token
}

@Post()
@UseGuards(JwtAuthGuard)
async upload(
  @Body() dto: CreateTrackDto,
  @CurrentUser() user: User, // ✅ Secure: from verified token
) {
  return this.service.create(dto, user.id);
}
```

### 21.4 Service Layer Pattern

Services receiving user-specific actions MUST accept `userId` as a separate parameter:

```typescript
@Injectable()
export class TracksService {
  async createFromUpload(
    file: Express.Multer.File,
    dto: CreateTrackDto,
    userId: string, // ✅ Received from controller, extracted from token
  ): Promise<Track> {
    // Use userId for ownership and quota checks
    const user = await this.usersService.findById(userId);
    // ... business logic
  }
}
```

### 21.5 @CurrentUser Decorator

**Location**: `src/auth/decorators/current-user.decorator.ts`

**Usage**: Extracts the authenticated user object from the request (populated by JwtStrategy)

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from '../../users/domain/user';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): User => {
    const request = ctx.switchToHttp().getRequest();
    return request.user; // Populated by JwtStrategy.validate()
  },
);
```

### 21.6 Public vs Protected Endpoints

**Public Endpoints** (no authentication required):

- Auth endpoints: `/auth/sign-in`, `/auth/sign-up`
- Public content: `/tracks/:id/stream` (read-only)
- Health checks, status pages

**Protected Endpoints** (JWT required):

- Create/Update/Delete operations: `POST /tracks`, `PUT /tracks/:id`
- User profile: `GET /users/me`, `PUT /users/me`
- User-specific listings: `GET /tracks/my-uploads`

### 21.7 Swagger/OpenAPI Documentation

Protected endpoints MUST include `@ApiBearerAuth()` decorator:

```typescript
@Post()
@UseGuards(JwtAuthGuard)
@ApiBearerAuth() // Adds "Authorize" button in Swagger
async upload(@CurrentUser() user: User) {
  // ...
}
```

This enables the "Authorize" button in Swagger UI where users can input their JWT token.

### 21.8 Error Handling

Authentication failures return standard HTTP status codes:

- `401 Unauthorized`: Missing or invalid JWT token
- `403 Forbidden`: Valid token but insufficient permissions
- `400 Bad Request`: Quota exceeded, validation errors

### 21.9 Checklist for Authenticated Endpoints

- [ ] `@UseGuards(JwtAuthGuard)` applied to controller method
- [ ] `@ApiBearerAuth()` added for Swagger documentation
- [ ] `@CurrentUser()` decorator used to extract user
- [ ] NO `userId` in request DTO
- [ ] Service method accepts `userId` as separate parameter
- [ ] Ownership/quota checks implemented in service layer

## 21. Migration Path for Existing Code

When refactoring existing modules to follow these rules:

1. **Enum extraction**:
   - Extract enum from domain/schema to `src/enums/{entity}-{type}.enum.ts`
   - Update all imports to use enums from `src/enums`

2. **Repository refactoring**:
   - Create `{entity}.repository.abstract.ts` with abstract methods
   - Update `{entity}.repository.ts` to extend abstract class and inject Mongoose Model
   - Change `implements IInterface` to `extends Abstract`

3. **Domain layer**:
   - Remove all ORM decorators (@Schema, @Prop, @Entity, @Column)
   - Keep pure interfaces and enum imports

4. **Schema layer (Mongoose)**:
   - Ensure all `@Schema` and `@Prop` decorators present
   - Add explicit `type` parameter for union types: `@Prop({ type: String, default: null })`
   - Import enums from `src/enums`
   - Use `HydratedDocument<T>` for type safety

5. **Mapper**:
   - Update `toEntity()` → `toDocument()`
   - Handle `_id` → `id` mapping in `toDomain()`
   - Exclude timestamps and id when mapping to document

6. **Service**:
   - Update repository type hints
   - No changes needed if using abstract repository pattern

7. **Persistence Module**:
   - Replace `TypeOrmModule.forFeature([Entity])` with `MongooseModule.forFeature([{ name: Document.name, schema: Schema }])`

8. **Testing**:
   - Test all endpoints, verify mapper transformations work
   - Verify enum usage consistent across layers
   - Mock Mongoose Model instead of TypeORM Repository

---

**Last Updated**: February 25, 2026  
**Version**: 2.0.0 (MongoDB + Mongoose)  
**Status**: Active
